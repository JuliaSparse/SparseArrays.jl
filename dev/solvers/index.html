<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse Linear Algebra API · SparseArrays</title><meta name="title" content="Sparse Linear Algebra API · SparseArrays"/><meta property="og:title" content="Sparse Linear Algebra API · SparseArrays"/><meta property="twitter:title" content="Sparse Linear Algebra API · SparseArrays"/><meta name="description" content="Documentation for SparseArrays."/><meta property="og:description" content="Documentation for SparseArrays."/><meta property="twitter:description" content="Documentation for SparseArrays."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SparseArrays</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SparseArrays</a></li><li class="is-active"><a class="tocitem" href>Sparse Linear Algebra API</a><ul class="internal"><li><a class="tocitem" href="#stdlib-sparse-linalg"><span>Sparse Linear Algebra</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sparse Linear Algebra API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sparse Linear Algebra API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSparse/SparseArrays.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/main/docs/src/solvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-Linear-Algebra-(API)"><a class="docs-heading-anchor" href="#Sparse-Linear-Algebra-(API)">Sparse Linear Algebra (API)</a><a id="Sparse-Linear-Algebra-(API)-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Linear-Algebra-(API)" title="Permalink"></a></h1><h2 id="stdlib-sparse-linalg"><a class="docs-heading-anchor" href="#stdlib-sparse-linalg">Sparse Linear Algebra</a><a id="stdlib-sparse-linalg-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-sparse-linalg" title="Permalink"></a></h2><p>Sparse matrix solvers call functions from <a href="http://suitesparse.com">SuiteSparse</a>.</p><p>The following factorizations are available:</p><ol><li><a href="#LinearAlgebra.cholesky-solvers"><code>cholesky</code></a></li><li><a href="#LinearAlgebra.ldlt-solvers"><code>ldlt</code></a></li><li><a href="#LinearAlgebra.lu-solvers"><code>lu</code></a></li><li><a href="#LinearAlgebra.qr-solvers"><code>qr</code></a></li></ol><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>CHOLMOD.Factor</code></td><td style="text-align: left">Cholesky and LDLt factorizations</td></tr><tr><td style="text-align: left"><code>UMFPACK.UmfpackLU</code></td><td style="text-align: left">LU factorization</td></tr><tr><td style="text-align: left"><code>SPQR.QRSparse</code></td><td style="text-align: left">QR factorization</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cholesky-solvers" href="#LinearAlgebra.cholesky-solvers"><code>LinearAlgebra.cholesky</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cholesky(A::SparseMatrixCSC; shift = 0.0, check = true, perm = nothing) -&gt; CHOLMOD.Factor</code></pre><p>Compute the Cholesky factorization of a sparse positive definite matrix <code>A</code>. <code>A</code> must be a <a href="../#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> or a <a href="@ref"><code>Symmetric</code></a>/<a href="@ref"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that if <code>A</code> doesn&#39;t have the type tag, it must itself be symmetric or Hermitian. If <code>perm</code> is not given, a fill-reducing permutation is used. <code>F = cholesky(A)</code> is most frequently used to solve systems of equations with <code>F\b</code>, but also the methods <a href="@ref"><code>diag</code></a>, <a href="@ref"><code>det</code></a>, and <a href="@ref"><code>logdet</code></a> are defined for <code>F</code>. You can also extract individual factors from <code>F</code>, using <code>F.L</code>. However, since pivoting is on by default, the factorization is internally represented as <code>A == P&#39;*L*L&#39;*P</code> with a permutation matrix <code>P</code>; using just <code>L</code> without accounting for <code>P</code> will give incorrect answers. To include the effects of permutation, it&#39;s typically preferable to extract &quot;combined&quot; factors like <code>PtL = F.PtL</code> (the equivalent of <code>P&#39;*L</code>) and <code>LtP = F.UP</code> (the equivalent of <code>L&#39;*P</code>).</p><p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition&#39;s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p><p>Setting the optional <code>shift</code> keyword argument computes the factorization of <code>A+shift*I</code> instead of <code>A</code>. If the <code>perm</code> argument is provided, it should be a permutation of <code>1:size(A,1)</code> giving the ordering to use (instead of CHOLMOD&#39;s default AMD ordering).</p><p>See also <a href="#LinearAlgebra.ldlt-solvers"><code>ldlt</code></a> for a similar factorization that does not require positive definiteness, but can be significantly slower than <code>cholesky</code>.</p><p><strong>Examples</strong></p><p>In the following example, the fill-reducing permutation used is <code>[3, 2, 1]</code>. If <code>perm</code> is set to <code>1:3</code> to enforce no permutation, the number of nonzero elements in the factor is 6.</p><pre><code class="language-julia-repl hljs">julia&gt; A = [2 1 1; 1 2 0; 1 0 2]
3×3 Matrix{Int64}:
 2  1  1
 1  2  0
 1  0  2

julia&gt; C = cholesky(sparse(A))
SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  5
nnz:     5
success: true

julia&gt; C.p
3-element Vector{Int64}:
 3
 2
 1

julia&gt; L = sparse(C.L);

julia&gt; Matrix(L)
3×3 Matrix{Float64}:
 1.41421   0.0       0.0
 0.0       1.41421   0.0
 0.707107  0.707107  1.0

julia&gt; L * L&#39; ≈ A[C.p, C.p]
true

julia&gt; P = sparse(1:3, C.p, ones(3))
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
  ⋅    ⋅   1.0
  ⋅   1.0   ⋅
 1.0   ⋅    ⋅

julia&gt; P&#39; * L * L&#39; * P ≈ A
true

julia&gt; C = cholesky(sparse(A), perm=1:3)
SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  6
nnz:     6
success: true

julia&gt; L = sparse(C.L);

julia&gt; Matrix(L)
3×3 Matrix{Float64}:
 1.41421    0.0       0.0
 0.707107   1.22474   0.0
 0.707107  -0.408248  1.1547

julia&gt; L * L&#39; ≈ A
true</code></pre><div class="admonition is-info" id="Note-e67ad49f3b811432"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e67ad49f3b811432" title="Permalink"></a></header><div class="admonition-body"><p>This method uses the CHOLMOD<sup class="footnote-reference"><a id="citeref-ACM887" href="#footnote-ACM887">[ACM887]</a></sup><sup class="footnote-reference"><a id="citeref-DavisHager2009" href="#footnote-DavisHager2009">[DavisHager2009]</a></sup> library from <a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a>. CHOLMOD only supports real or complex types in single or double precision. Input matrices not of those element types will be converted to these types as appropriate.</p><p>Many other functions from CHOLMOD are wrapped but not exported from the <code>Base.SparseArrays.CHOLMOD</code> module.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/bb5ecc0917b6ad98ffae5b1269e305616509fd2f/src/solvers/cholmod.jl#L1540-L1649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cholesky!-solvers" href="#LinearAlgebra.cholesky!-solvers"><code>LinearAlgebra.cholesky!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cholesky!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -&gt; CHOLMOD.Factor</code></pre><p>Compute the Cholesky (<span>$LL&#39;$</span>) factorization of <code>A</code>, reusing the symbolic factorization <code>F</code>. <code>A</code> must be a <a href="../#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> or a <a href="@ref"><code>Symmetric</code></a>/ <a href="@ref"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that if <code>A</code> doesn&#39;t have the type tag, it must itself be symmetric or Hermitian.</p><p>See also <a href="#LinearAlgebra.cholesky-solvers"><code>cholesky</code></a>.</p><div class="admonition is-info" id="Note-c89e10186e5c899a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c89e10186e5c899a" title="Permalink"></a></header><div class="admonition-body"><p>This method uses the CHOLMOD library from SuiteSparse, which only supports real or complex types in single or double precision. Input matrices not of those element types will be converted to these types as appropriate.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/bb5ecc0917b6ad98ffae5b1269e305616509fd2f/src/solvers/cholmod.jl#L1504-L1519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankdowndate-solvers" href="#LinearAlgebra.lowrankdowndate-solvers"><code>LinearAlgebra.lowrankdowndate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankdowndate(F::CHOLMOD.Factor, C::AbstractArray) -&gt; FF::CHOLMOD.Factor</code></pre><p>Get an <code>LDLt</code> Factorization of <code>A + C*C&#39;</code> given an <code>LDLt</code> or <code>LLt</code> factorization <code>F</code> of <code>A</code>.</p><p>The returned factor is always an <code>LDLt</code> factorization.</p><p>See also <a href="#LinearAlgebra.lowrankdowndate!-solvers"><code>lowrankdowndate!</code></a>, <a href="@ref"><code>lowrankupdate</code></a>, <a href="@ref"><code>lowrankupdate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/bb5ecc0917b6ad98ffae5b1269e305616509fd2f/src/solvers/cholmod.jl#L1830-L1838">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankdowndate!-solvers" href="#LinearAlgebra.lowrankdowndate!-solvers"><code>LinearAlgebra.lowrankdowndate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankdowndate!(F::CHOLMOD.Factor, C::AbstractArray)</code></pre><p>Update an <code>LDLt</code> or <code>LLt</code> Factorization <code>F</code> of <code>A</code> to a factorization of <code>A - C*C&#39;</code>.</p><p><code>LLt</code> factorizations are converted to <code>LDLt</code>.</p><p>See also <a href="#LinearAlgebra.lowrankdowndate-solvers"><code>lowrankdowndate</code></a>, <a href="@ref"><code>lowrankupdate</code></a>, <a href="@ref"><code>lowrankupdate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/bb5ecc0917b6ad98ffae5b1269e305616509fd2f/src/solvers/cholmod.jl#L1800-L1808">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.CHOLMOD.lowrankupdowndate!-solvers" href="#SparseArrays.CHOLMOD.lowrankupdowndate!-solvers"><code>SparseArrays.CHOLMOD.lowrankupdowndate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankupdowndate!(F::CHOLMOD.Factor, C::Sparse, update::Cint)</code></pre><p>Update an <code>LDLt</code> or <code>LLt</code> Factorization <code>F</code> of <code>A</code> to a factorization of <code>A ± C*C&#39;</code>.</p><p>If sparsity preserving factorization is used, i.e. <code>L*L&#39; == P*A*P&#39;</code> then the new factor will be <code>L*L&#39; == P*A*P&#39; + C&#39;*C</code></p><p><code>update</code>: <code>Cint(1)</code> for <code>A + CC&#39;</code>, <code>Cint(0)</code> for <code>A - CC&#39;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/bb5ecc0917b6ad98ffae5b1269e305616509fd2f/src/solvers/cholmod.jl#L1769-L1778">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldlt-solvers" href="#LinearAlgebra.ldlt-solvers"><code>LinearAlgebra.ldlt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ldlt(A::SparseMatrixCSC; shift = 0.0, check = true, perm=nothing) -&gt; CHOLMOD.Factor</code></pre><p>Compute the <span>$LDL&#39;$</span> factorization of a sparse matrix <code>A</code>. <code>A</code> must be a <a href="../#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> or a <a href="@ref"><code>Symmetric</code></a>/<a href="@ref"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that if <code>A</code> doesn&#39;t have the type tag, it must itself be symmetric or Hermitian. A fill-reducing permutation is used. <code>F = ldlt(A)</code> is most frequently used to solve systems of equations <code>A*x = b</code> with <code>F\b</code>. The returned factorization object <code>F</code> also supports the methods <a href="@ref"><code>diag</code></a>, <a href="@ref"><code>det</code></a>, <a href="@ref"><code>logdet</code></a>, and <a href="@ref"><code>inv</code></a>. You can extract individual factors from <code>F</code> using <code>F.L</code>. However, since pivoting is on by default, the factorization is internally represented as <code>A == P&#39;*L*D*L&#39;*P</code> with a permutation matrix <code>P</code>; using just <code>L</code> without accounting for <code>P</code> will give incorrect answers. To include the effects of permutation, it is typically preferable to extract &quot;combined&quot; factors like <code>PtL = F.PtL</code> (the equivalent of <code>P&#39;*L</code>) and <code>LtP = F.UP</code> (the equivalent of <code>L&#39;*P</code>). The complete list of supported factors is <code>:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP</code>.</p><p>Unlike the related Cholesky factorization, the <span>$LDL&#39;$</span> factorization does not require <code>A</code> to be positive definite. However, it still requires all leading principal minors to be well-conditioned and will fail if this is not satisfied.</p><p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition&#39;s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p><p>Setting the optional <code>shift</code> keyword argument computes the factorization of <code>A+shift*I</code> instead of <code>A</code>. If the <code>perm</code> argument is provided, it should be a permutation of <code>1:size(A,1)</code> giving the ordering to use (instead of CHOLMOD&#39;s default AMD ordering).</p><p>See also <a href="#LinearAlgebra.cholesky-solvers"><code>cholesky</code></a> for a factorization that can be significantly faster than <code>ldlt</code>, but requires <code>A</code> to be positive definite.</p><div class="admonition is-info" id="Note-e67ad49f3b811432"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e67ad49f3b811432" title="Permalink"></a></header><div class="admonition-body"><p>This method uses the CHOLMOD<sup class="footnote-reference"><a id="citeref-ACM887" href="#footnote-ACM887">[ACM887]</a></sup><sup class="footnote-reference"><a id="citeref-DavisHager2009" href="#footnote-DavisHager2009">[DavisHager2009]</a></sup> library from <a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a>. CHOLMOD only supports real or complex types in single or double precision. Input matrices not of those element types will be converted to these types as appropriate.</p><p>Many other functions from CHOLMOD are wrapped but not exported from the <code>Base.SparseArrays.CHOLMOD</code> module.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/bb5ecc0917b6ad98ffae5b1269e305616509fd2f/src/solvers/cholmod.jl#L1716-L1760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.qr-solvers" href="#LinearAlgebra.qr-solvers"><code>LinearAlgebra.qr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr(A::SparseMatrixCSC; tol=_default_tol(A), ordering=ORDERING_DEFAULT) -&gt; QRSparse</code></pre><p>Compute the <code>QR</code> factorization of a sparse matrix <code>A</code>. Fill-reducing row and column permutations are used such that <code>F.R = F.Q&#39;*A[F.prow,F.pcol]</code>. The main application of this type is to solve least squares or underdetermined problems with <a href="@ref"><code>\</code></a>. The function calls the C library SPQR<sup class="footnote-reference"><a id="citeref-ACM933" href="#footnote-ACM933">[ACM933]</a></sup>.</p><div class="admonition is-info" id="Note-d7a550cfb4145c1a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d7a550cfb4145c1a" title="Permalink"></a></header><div class="admonition-body"><p><code>qr(A::SparseMatrixCSC)</code> uses the SPQR library that is part of <a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a>. As this library only supports sparse matrices with <a href="@ref"><code>Float64</code></a> or <code>ComplexF64</code> elements, as of Julia v1.4 <code>qr</code> converts <code>A</code> into a copy that is of type <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{ComplexF64}</code> as appropriate.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse([1,2,3,4], [1,1,2,2], [1.0,1.0,1.0,1.0])
4×2 SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 1.0   ⋅
 1.0   ⋅
  ⋅   1.0
  ⋅   1.0

julia&gt; qr(A)
SparseArrays.SPQR.QRSparse{Float64, Int64}
Q factor:
4×4 SparseArrays.SPQR.QRSparseQ{Float64, Int64}
R factor:
2×2 SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 -1.41421    ⋅
   ⋅       -1.41421
Row permutation:
4-element Vector{Int64}:
 1
 3
 4
 2
Column permutation:
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/bb5ecc0917b6ad98ffae5b1269e305616509fd2f/src/solvers/spqr.jl#L151-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lu-solvers" href="#LinearAlgebra.lu-solvers"><code>LinearAlgebra.lu</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lu(A::AbstractSparseMatrixCSC; check = true, q = nothing, control = get_umfpack_control()) -&gt; F::UmfpackLU</code></pre><p>Compute the LU factorization of a sparse matrix <code>A</code>.</p><p>For sparse <code>A</code> with real or complex element type, the return type of <code>F</code> is <code>UmfpackLU{Tv, Ti}</code>, with <code>Tv</code> = <a href="@ref"><code>Float64</code></a> or <code>ComplexF64</code> respectively and <code>Ti</code> is an integer type (<a href="@ref"><code>Int32</code></a> or <a href="@ref"><code>Int64</code></a>).</p><p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition&#39;s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p><p>The permutation <code>q</code> can either be a permutation vector or <code>nothing</code>. If no permutation vector is provided or <code>q</code> is <code>nothing</code>, UMFPACK&#39;s default is used. If the permutation is not zero-based, a zero-based copy is made.</p><p>The <code>control</code> vector defaults to the Julia SparseArrays package&#39;s default configuration for UMFPACK (NB: this is modified from the UMFPACK defaults to disable iterative refinement), but can be changed by passing a vector of length <code>UMFPACK_CONTROL</code>, see the UMFPACK manual for possible configurations.  For example to reenable iterative refinement:</p><pre><code class="language-julia hljs">umfpack_control = SparseArrays.UMFPACK.get_umfpack_control(Float64, Int64) # read Julia default configuration for a Float64 sparse matrix
SparseArrays.UMFPACK.show_umf_ctrl(umfpack_control) # optional - display values
umfpack_control[SparseArrays.UMFPACK.JL_UMFPACK_IRSTEP] = 2.0 # reenable iterative refinement (2 is UMFPACK default max iterative refinement steps)

Alu = lu(A; control = umfpack_control)
x = Alu \ b   # solve Ax = b, including UMFPACK iterative refinement</code></pre><p>The individual components of the factorization <code>F</code> can be accessed by indexing:</p><table><tr><th style="text-align: left">Component</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>L</code></td><td style="text-align: left"><code>L</code> (lower triangular) part of <code>LU</code></td></tr><tr><td style="text-align: left"><code>U</code></td><td style="text-align: left"><code>U</code> (upper triangular) part of <code>LU</code></td></tr><tr><td style="text-align: left"><code>p</code></td><td style="text-align: left">right permutation <code>Vector</code></td></tr><tr><td style="text-align: left"><code>q</code></td><td style="text-align: left">left permutation <code>Vector</code></td></tr><tr><td style="text-align: left"><code>Rs</code></td><td style="text-align: left"><code>Vector</code> of scaling factors</td></tr><tr><td style="text-align: left"><code>:</code></td><td style="text-align: left"><code>(L,U,p,q,Rs)</code> components</td></tr></table><p>The relation between <code>F</code> and <code>A</code> is</p><p><code>F.L*F.U == (F.Rs .* A)[F.p, F.q]</code></p><p><code>F</code> further supports the following functions:</p><ul><li><a href="@ref"><code>\</code></a></li><li><a href="@ref"><code>det</code></a></li></ul><p>See also <a href="@ref"><code>lu!</code></a></p><div class="admonition is-info" id="Note-cf936c9dfceef2bb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-cf936c9dfceef2bb" title="Permalink"></a></header><div class="admonition-body"><p><code>lu(A::AbstractSparseMatrixCSC)</code> uses the UMFPACK<sup class="footnote-reference"><a id="citeref-ACM832" href="#footnote-ACM832">[ACM832]</a></sup> library that is part of <a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a>. As this library only supports sparse matrices with <a href="@ref"><code>Float64</code></a> or <code>ComplexF64</code> elements, <code>lu</code> converts <code>A</code> into a copy that is of type <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{ComplexF64}</code> as appropriate.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/bb5ecc0917b6ad98ffae5b1269e305616509fd2f/src/solvers/umfpack.jl#L310-L368">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-ACM887"><a class="tag is-link" href="#citeref-ACM887">ACM887</a>Chen, Y., Davis, T. A., Hager, W. W., &amp; Rajamanickam, S. (2008). Algorithm 887: CHOLMOD, Supernodal Sparse Cholesky Factorization and Update/Downdate. ACM Trans. Math. Softw., 35(3). <a href="https://doi.org/10.1145/1391989.1391995">doi:10.1145/1391989.1391995</a></li><li class="footnote" id="footnote-DavisHager2009"><a class="tag is-link" href="#citeref-DavisHager2009">DavisHager2009</a>Davis, Timothy A., &amp; Hager, W. W. (2009). Dynamic Supernodes in Sparse Cholesky Update/Downdate and Triangular Solves. ACM Trans. Math. Softw., 35(4). <a href="https://doi.org/10.1145/1462173.1462176">doi:10.1145/1462173.1462176</a></li><li class="footnote" id="footnote-ACM933"><a class="tag is-link" href="#citeref-ACM933">ACM933</a>Foster, L. V., &amp; Davis, T. A. (2013). Algorithm 933: Reliable Calculation of Numerical Rank, Null Space Bases, Pseudoinverse Solutions, and Basic Solutions Using SuitesparseQR. ACM Trans. Math. Softw., 40(1). <a href="https://doi.org/10.1145/2513109.2513116">doi:10.1145/2513109.2513116</a></li><li class="footnote" id="footnote-ACM832"><a class="tag is-link" href="#citeref-ACM832">ACM832</a>Davis, Timothy A. (2004b). Algorithm 832: UMFPACK V4.3—an Unsymmetric-Pattern Multifrontal Method. ACM Trans. Math. Softw., 30(2), 196–199. <a href="https://doi.org/10.1145/992200.992206">doi:10.1145/992200.992206</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« SparseArrays</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 10 August 2025 13:02">Sunday 10 August 2025</span>. Using Julia version 1.13.0-DEV.972.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
